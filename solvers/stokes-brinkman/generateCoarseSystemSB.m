function CS = generateCoarseSystemSB(G, rock, Dofs, CG, fluid, element, ...
              basis, varargin)
% generateCoarseSystemSB -- Construct coarse system component matrices from
%                            underlying fine grid model.
%
% SYNOPSIS:
%   CS = generateCoarseSystemSB(G, rock, Dofs, CG, fluid, element, basis)
%   CS = generateCoarseSystemSB(G, rock, Dofs, CG, fluid, element, basis,...
%                               'pn1', pv1, ...)
%
% PARAMETERS:
%   G       - Grid structure as described in SAMSIMGRID.
%
%   rock    - Rock data structure with valid field 'perm'. If the basis
%             functions are to be weighted by porosity, rock must also
%             contain a valid field 'poros'.
%
%   Dofs    - Degrees of Freedom as generated by 'findCartDofs'.
% 
%   CG      - Coarse grid structure as defined by 'generateCoarseGrid'.
%
%   fluid   - Fluid object containing 'fluid.mu' (water viscosity) and
%             'fluid.mu_eff' (the effective viscosity).
%
%   element  - A string explaining which elements are used (ex. 'TH').
%
%   basis    - A string explaining which basis is used (ex. 'TH').
%
%   'pn'/pv  - List of 'key'/value pairs defining optional parameters.  The
%             supported options are:
%               - BasisWeighting -- Scalar field defining how to construct
%                                   synthetic source terms for flux basis
%                                   functions.  Either a string with values
%                                   taken from the table below (default
%                                   value 'perm'), or an array of already
%                                   evaluated synthetic source terms (one
%                                   non-negative scalar value for each cell
%                                   in the fine-scale model).
%                 The supported string values are:
%                     - 'perm'   : Weigh sources according to TRACE(K).
%                     - 'poros'  : weigh sources according to porosity.
%                     - 'unit'   : uniform sources.
%
%               - Verbose -- Whether or not to emit progress reports while
%                            computing basis functions.
%                            Logical.  Default value = FALSE.
%
%               - Overlap -- Number of fine-grid cells in each physical
%                            direction with which to extend the supporting
%                            domain of any given basis functions.
%
%                            Using overlapping domains enables capturing
%                            more complex flow patterns, particularly for
%                            very coarse grids, at the expense of increased
%                            coupling in the resulting systems of linear
%                            equations.
%                            Non-negative integers.  Default value = 0.
%
%                            Note: Positive overlap is only supported if
%                            the system structure 'S' was created by
%                            passing option pair ('Type','mixed') to
%                            function assembleMimeticSystem (i.e., if field
%                            'S.B' is present).
%
%               - ActiveBndFaces -- Vector of active coarse boundary faces
%                                   Default value=[] (only no-flow bc).
%                                   (Coarse faces with prescribed
%                                    fine-scale bc's are always considered
%                                    active.)
%
%               - bc  -- Boundary condtion structure as defined by function
%                        'addBCSB'.  This structure accounts for all external
%                        boundary contributions to the reservoir flow.
%                        Default value: bc = [] meaning all external
%                        no-flow (homogeneous Neumann) conditions.
%
%               - src -- Explicit source contributions as defined by
%                        function 'addSource'.
%                        Default value: src = [] meaning no explicit
%                        sources exist in the model.
%
%   LinSolve     - Handle to linear system solver software to which the
%                  fully assembled system of linear equations will be
%                  passed.  Assumed to support the syntax
%
%                        x = LinSolve(A, b)
%
%                  in order to solve a system Ax=b of linear equations.
%                  Default value: LinSolve = @mldivide (backslash).
%

[verbose, weight, weighting, overlap, activeBnd, src, bc, linSolv] = ...
    parse_args(G, CG, rock, varargin{:});

% Determine boundary faces for which basis functions will be assigned.
%
if ~isempty(bc),
  activeBnd = unique([activeBnd; has_bc(G, CG, bc)]);
end

dim = numel(G.cartDims);
  
%% Generate basis (Taylor-Hood)
activeFaces = [find(all(CG.faces.neighbors > 0, 2)); activeBnd];
CS.basis    = cell([CG.faces.num, 1]);
CS.basisP   = cell([CG.faces.num, 1]);
 
V = evalBasisFuncTH(activeFaces, G, CG, Dofs, weight, fluid, rock,...
                    element, basis, 'src', src, 'bc', bc, ...
                    'Verbose', verbose, 'LinSolve', linSolv); 

if dim==2
  f = cellfun(@(x) x{4}, V);
elseif dim==3
  f = cellfun(@(x) x{5}, V);
end
CS.basis (f) = V;


%% Define coarse system structure 'CS'.
%
% 1) Compute coarse grid matrices C and D.
% Note: The saturation dependent coarse mass matrix B is evaluated in
%       function 'solveIncompFlowMS'

% Compute sizes for matrices 'B', 'C', and 'D'.  Includes all faces, even
% faces for which there are no associated degrees of freedom.
sizeB    = size(CG.cellFaces, 1) * [1, 1];
sizeC    = [sizeB(1), double(CG.cells.num)];
sizeD    = [sizeB(1), double(CG.faces.num)];

% Compute topology matrices (C and D).
topo_mat = @(j,n) sparse(1:numel(j), double(j), 1, numel(j), n);
CS.C     = topo_mat(CG.cellFaces(:,1), sizeC(2));
CS.D     = topo_mat(CG.cellFaces(:,2), sizeD(2));

% 2) Define degrees of freedom and basis function weighting scheme.
%
CS.basisWeighting  = weighting;
CS.activeFaces     = activeFaces;
CS.activeCellFaces = find(sum(CS.D(:,activeFaces), 2));

% 3) Assign system matrix sizes for ease of implementation elsewhere.
CS.type  = 'hybrid';
CS.sizeB = sizeB;
CS.sizeC = sizeC;
CS.sizeD = sizeD;

%-----------------------------------------------------------------------
% Private helpers follow
%-----------------------------------------------------------------------

function [verbose, weight, weighting, ...
          overlap, activeBnd, src, bc, linSolv] = parse_args(G, CG, rock, varargin)
  opt = struct('Verbose',        false,  ...
               'BasisWeighting', 'perm', ...
               'Overlap',        0,      ...
               'ActiveBndFaces', [], 'src', [], 'bc', [], 'LinSolve', @mldivide);
  opt = merge_options(opt, varargin{:});
  
  verbose   = opt.Verbose;
  weighting = opt.BasisWeighting;
  overlap   = opt.Overlap;
  activeBnd = opt.ActiveBndFaces;
  src       = opt.src;
  bc        = opt.bc;
  linSolv   = opt.LinSolve;
  
weight    = evalBasisSource(G, weighting, rock);

if any(activeBnd > CG.faces.num),
   nonext = activeBnd(activeBnd > CG.faces.num);
   s = ''; if numel(nonext) > 1, s = 's'; end
   error(id('CoarseFace:NonExistent'), ...
         ['Cowardly refusing to assign basis function on ', ...
          'non-existent coarse face%s: [%s].'], s, int2str(nonext));
elseif any(~any(CG.faces.neighbors(activeBnd,:) == 0, 2)),
   error(id('ActiveBndFaces:NotBoundary'), ...
         'Given ''activeBndFaces'' are not on boundary.');
end

%-----------------------------------------------------------------------

function ix = has_bc(G, CG, bc)
[nsub, sub] = subFaces(G, CG);
f2c         = sparse(sub, 1, rldecode((1 : double(CG.faces.num)) .', nsub));

% Note:
%   This code assumes that any Neumann conditions specified on the fine
%   scale grid amounts to flow only one way across a coarse face.  If the
%   Neumann conditions amount to zero net flow across a coarse face, the
%   resulting flux basis function is undefined...
%
flow_support                 = false([CG.faces.num, 1]);
flow_support(f2c([bc.face(bc.type==2)])) = true;

ix = find(flow_support);

%-----------------------------------------------------------------------

function s = id(s)
s = ['generateCoarseSystem:', s];
