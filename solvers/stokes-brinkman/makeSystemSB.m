function S = makeSystemSB(G, Dofs, rock, fluid, varargin)
% makeSystemSB -- Construct a mixed 2-D or 3-D system with Taylor-Hood
% elements based on grid, rock and sources/sinks.
%
% SYNOPSIS:
%   S = makeSystemSB(G, Dofs,rock, fluid)
%   S = makeSystemSB(G, Dofs,rock, fluid, 'pn',pv,...)
%
% PARAMETERS:
%
%   G     - Grid structure as generated by cartGrid.
%
%   Dofs  - Degrees-of-freedom structure as generated by 'findCartDofs'.
%
%   rock  - Rock data structure with valid field 'perm'.
%
%   fluid - Fluid object containing 'fluid.mu' (water viscosity) and
%           'fluid.mu_eff' (the effective viscosity).
%
%   'pn'/pv - List of 'key'/value pairs defining optional parameters.  The
%             supported options are:
%     - dx --  A structure with fields 'dx', 'dy', (and 'dz')
%              containing a vector with values for each cell.'
%
%     - element --The name of a file containing element
%                 matrices. Default file = 'ElementMat2D'/'...3D'.
%
%     - basis --  The name of a file containing basis
%                 functions. Default = 'TH'.
%
%     - bc --  Boundary condition structure from a prior call to 'addBCSB'
%              or an empty structure, which will automatically give no-flow
%              conditions.
%
%  
% RETURNS:
%   S - System structure having the following fields:
%         - B1, B2, (B3): B for v1, v2 (and v3) in mixed system with
%                         Taylor-Hood elements
%         - C1, C2, (C3): C in mixed system (TH)
%         - P0          : zeros(size(C1,1),size(C1,1))
%         - F1, F2, (F3): zeros(size(B1,1),1), zeros(size(B2,1),1),
%                         (zeros(size(B3,1),1))
%         - Q           : zeros(size(C1,1));
%
% COMMENTS:
%  In the mixed discretization with Taylor-Hood elements, the matrices
%  appear as
%
%       [B1   0   C1]   [v1] [F1]       [B1   0   0   C1]   [v1] [F1]
%       [0    B2  C2] * [v2]=[F2] or    [0    B2  0   C2] * [v2]=[F2]
%       [C1'  C2' PO]   [-p] [Q ]       [0    0   B3  C3]   [v3]=[F3]
%                                       [C1'  C2' C3' PO]   [-p] [Q ]
%
% All no-flow boundary conditions are automatically included in the system
% when element = 'TH'.

% $Date: 2009-10-12 12:17:55 +0200 (ma, 12 okt 2009) $
% $Revision: 2977 $

%---------------------------------------------------------------------%
%  Build the system
%---------------------------------------------------------------------%
  
  error(nargchk(4, 10, nargin, 'struct'));
  
  opt = struct('dx', [],'element','TH', 'basis', 'TH', 'bc', []);
  opt = merge_options(opt, varargin{:});

  
  BC = opt.bc;
     
  dxvec   = opt.dx;
  element = opt.element;
  basis   = opt.basis;
  dim     = size(G.nodes.coords, 2);
  
  assert (sum(dim == [2, 3]) == 1);
  
  % Load matrices for the reference element
  if strcmp(element, 'TH'),
     load(sbpath(['ElementMat', int2str(dim), 'D']));
  else
     load(element);
  end
  
  if isempty(dxvec)
     dxi = G.cellFaces(:,2)==1;  dxj = G.cellFaces(:,2)==2;
     dyi = G.cellFaces(:,2)==3;  dyj = G.cellFaces(:,2)==4;
     dx  = G.faces.centroids(G.cellFaces(dxj,1),1)-...
        G.faces.centroids(G.cellFaces(dxi,1),1);
     dy  = G.faces.centroids(G.cellFaces(dyj,1),2)-...
        G.faces.centroids(G.cellFaces(dyi,1),2);
     if dim==3
        dzi = G.cellFaces(:,2)==5;  dzj = G.cellFaces(:,2)==6;
        dz  = G.faces.centroids(G.cellFaces(dzj,1),3)- ...
           G.faces.centroids(G.cellFaces(dzi,1),3);
     end
  else
     dx = dxvec.dx;
     dy = dxvec.dy;
     if dim==3
        dz = dxvec.dz;
     end
  end
  % define permeability
  if size(rock.perm,2)==2
     KIx = 1./rock.perm(:,1);
     KIy = 1./rock.perm(:,2);
  elseif size(rock.perm,2)==3
     KIx = 1./rock.perm(:,1);
     KIy = 1./rock.perm(:,2);
     KIz = 1./rock.perm(:,3);
  elseif size(rock.perm,2)==1
     KIx = 1./rock.perm(:);
     KIy = 1./rock.perm(:);
     if dim==3
        KIz = 1./rock.perm(:);
     end
  end
  
  mu       = fluid.mu;      mut      = fluid.mu_eff;
  numVdofs = Dofs.numVdofs; numPdofs = Dofs.numPdofs;
  
  P0   = sparse(numPdofs,numPdofs);
  B_I  = zeros([size(Dofs.Vdofs,2)*size(Dofs.Vdofs,2)*G.cells.num, 1]);
  [B_J, B1_V, B2_V] = deal(B_I);
  
  C_I  = zeros([size(Dofs.Vdofs,2)*size(Dofs.Pdofs,2)*G.cells.num, 1]);
  [C_J, C2_V, C1_V] = deal(C_I);
  
  if dim==3
     B3_V = B_I;
     C3_V = C_I;
  end
  
  % Loop over all cells
  for i = 1:G.cells.num,
     %global index to vdofs and pdofs in cell i
     Iv = Dofs.Vdofs(i,:);          Ip = Dofs.Pdofs(i,:);
     
     locixB = size(Dofs.Vdofs,2)*size(Dofs.Vdofs,2)*(i-1)+1:...
        size(Dofs.Vdofs,2)*size(Dofs.Vdofs,2)*i;
     locixC = size(Dofs.Pdofs,2)*size(Dofs.Vdofs,2)*(i-1)+1:...
        size(Dofs.Pdofs,2)*size(Dofs.Vdofs,2)*i;
     
     %% K11, K22 and K33
     %B1(Iv,Iv)=B1(Iv,Iv)+dx*dy*dz/8*Kx(i)*mu*VV+mut*dy*dz/2/dx*VxVx+
     %                       mut*dx*dz/2/dy*VyVy+mut*dx*dy/2/dz*VzVz;
     %B2(Iv,Iv)=B2(Iv,Iv)+dx*dy*dz/8*Ky(i)*mu*VV+mut*dy*dz/2/dx*VxVx+
     %                       mut*dx*dz/2/dy*VyVy+mut*dx*dy/2/dz*VzVz;
     %B3(Iv,Iv)=B3(Iv,Iv)+dx*dy*dz/8*Kz(i)*mu*VV+mut*dy*dz/2/dx*VxVx+
     %                       mut*dx*dz/2/dy*VyVy+mut*dx*dy/2/dz*VzVz;
     
     B_I(locixB) = reshape(repmat(Iv.', [1, size(Dofs.Vdofs,2)]), [], 1);
     B_J(locixB) = reshape(repmat(Iv,   [size(Dofs.Vdofs,2), 1]), [], 1);
     
     if dim==2
        
        val1 = dx(i)*dy(i)/4*KIx(i)*mu*M.VV+mut*dy(i)/dx(i)*M.VxVx+...
           mut*dx(i)/dy(i)*M.VyVy;
        val2 = dx(i)*dy(i)/4*KIy(i)*mu*M.VV+mut*dy(i)/dx(i)*M.VxVx+...
           mut*dx(i)/dy(i)*M.VyVy;
        
        B1_V(locixB) = val1(:); B2_V(locixB) = val2(:);
        
     elseif dim==3
        
        val1 = dx(i)*dy(i)*dz(i)/8*KIx(i)*mu*M.VV+mut*dy(i)*dz(i)/2/dx(i)*M.VxVx+...
           mut*dx(i)*dz(i)/2/dy(i)*M.VyVy+mut*dx(i)*dy(i)/2/dz(i)*M.VzVz;
        val2 = dx(i)*dy(i)*dz(i)/8*KIy(i)*mu*M.VV+mut*dy(i)*dz(i)/2/dx(i)*M.VxVx+...
           mut*dx(i)*dz(i)/2/dy(i)*M.VyVy+mut*dx(i)*dy(i)/2/dz(i)*M.VzVz;
        val3 = dx(i)*dy(i)*dz(i)/8*KIz(i)*mu*M.VV+mut*dy(i)*dz(i)/2/dx(i)*M.VxVx+...
           mut*dx(i)*dz(i)/2/dy(i)*M.VyVy+mut*dx(i)*dy(i)/2/dz(i)*M.VzVz;
        
        B1_V(locixB) = val1(:); B2_V(locixB) = val2(:); B3_V(locixB) = val3(:);
        
     end
     
     %% K14, K24, K34 and K41', K42', K43'
     
     %Cv1(Iv,Ip)=Cv1(Iv,Ip) + dy*dz/4*VxP;
     %Cv2(Iv,Ip)=Cv2(Iv,Ip) + dx*dz/4*VyP;
     %Cv3(Iv,Ip)=Cv3(Iv,Ip) + dx*dy/4*VzP;
     
     C_I(locixC) = reshape(repmat(Iv.', [1, size(Dofs.Pdofs,2)]), [], 1);
     C_J(locixC) = reshape(repmat(Ip,   [size(Dofs.Vdofs,2), 1]), [], 1);
     
     if dim==2
        
        val1 =  dy(i)/2*M.VxP;
        val2 =  dx(i)/2*M.VyP;
        
        C1_V(locixC) = val1(:); C2_V(locixC) = val2(:);
        
     elseif dim==3
        
        val1 =  dy(i)*dz(i)/4*M.VxP;
        val2 =  dx(i)*dz(i)/4*M.VyP;
        val3 =  dx(i)*dy(i)/4*M.VzP;
        
        C1_V(locixC) = val1(:); C2_V(locixC) = val2(:); C3_V(locixC) = val3(:);
        
     end
  end
    
  %% Set no-flow bc for Taylor Hood elements
  
  if strcmp(element,'TH')
     
     if isempty(BC)  % apply no-flow boundary everywhere
        fprintf('Applying no-flow bc on entire boundary\n '); 
        ind     = any(G.faces.neighbors==0,2);
        bcfaces = find(ind);
        BC      = addBCSB([],bcfaces, 'velocity_n', ...
                          repmat(0,numel(bcfaces),1), G, Dofs);
     end
     
     isVeln  = BC.nodetype == 1; %strcmp('velocity_n',BC.nodetype);
     BCdofs  = BC.node(isVeln);
     BCval   = BC.nodevalue(isVeln);
     
     % check that all boundary conditions are no-flow
     assert(all(BCval == 0));
     
     BCtag   = BC.nodetag(isVeln);
     
     % Separate the upper, lower, left and right boundaries
     ile = BCtag==1; BCdofs_le = unique(BCdofs(ile));
     ir  = BCtag==2; BCdofs_r  = unique(BCdofs(ir));
     il  = BCtag==3; BCdofs_l  = unique(BCdofs(il));
     iu  = BCtag==4; BCdofs_u  = unique(BCdofs(iu));
     ib  = BCtag==5; BCdofs_b  = unique(BCdofs(ib));
     it  = BCtag==6; BCdofs_t  = unique(BCdofs(it));
     
     BCdofs_le_r = [BCdofs_le; BCdofs_r];  % left and right boundary
     BCdofs_l_u  = [BCdofs_l; BCdofs_u];   % lower and upper boundary
     BCdofs_b_t  = [BCdofs_b; BCdofs_t];   % bottom and top boundary
     
     % Identify diagonal elements in B matrix     
     diag = B_I == B_J;
     
     % left and right boundary, remove all contributions from nodes
     % associated with noflow face, and put diagonal element = 1
     if ~isempty(BCdofs_le_r)
        i = ismember(B_I, BCdofs_le_r);
        j = ismember(B_J, BCdofs_le_r);
        k = ismember(C_I, BCdofs_le_r);
        B1_V(i | j) = 0;
        % change value of diagonal elements
        B1_V(diag & i)= mean(abs(B1_V));
        C1_V(k) = 0;
     end
     % lower and upper boundary, remove all contributions from nodes
     % associated with noflow face
     if ~isempty(BCdofs_l_u)
        i = ismember(B_I, BCdofs_l_u);
        j = ismember(B_J, BCdofs_l_u);
        k = ismember(C_I, BCdofs_l_u);
        B2_V(i|j)= 0;
        % change value of diagonal elements
        B2_V(diag & i)= mean(abs(B2_V));
        C2_V(k) = 0;
     end
     % top and bottom boundary, remove all contributions from nodes
     % associated with noflow face
     if ~isempty(BCdofs_b_t)
        i = ismember(B_I, BCdofs_b_t);
        j = ismember(B_J, BCdofs_b_t);
        k = ismember(C_I, BCdofs_b_t);
        B3_V(i|j)= 0;
        % change value of diagonal elements
        B3_V(diag & i)= mean(abs(B3_V));
        C3_V(k) = 0;
     end   
  end
  
  
  %% Generate sparse matrices
  
  B1 = sparse(B_I,B_J,B1_V);
  B2 = sparse(B_I,B_J,B2_V);
  C1 = sparse(C_I,C_J,C1_V);
  C2 = sparse(C_I,C_J,C2_V);
  F1 = sparse(numVdofs,1);
  F2 = sparse(numVdofs,1);
  Q  = sparse(numPdofs,1);
  if dim==3
     B3 = sparse(B_I,B_J,B3_V);
     C3 = sparse(C_I,C_J,C3_V);
     F3 = sparse(numVdofs,1);
  end
  
  S.B1 = B1;
  S.B2 = B2;
  S.C1 = C1;
  S.C2 = C2;
  S.P0 = P0;
  S.F1 = F1;
  S.F2 = F2;
  S.Q  = Q;
  if dim==3
     S.B3 = B3;
     S.C3 = C3;
     S.F3 = F3;
  end
  
  S.basis   = basis;
  S.element = element;
end

function p = sbpath(p)
   p = fullfile(ROOTDIR, 'solvers', 'stokes-brinkman', p);
end
