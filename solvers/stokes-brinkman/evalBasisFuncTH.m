function V = evalBasisFuncTH(faces, G, CG, Dofs, w, fluid, rock, ...
                                 element, basis, varargin)
% evalBasisFuncTH -- Computes multiscale Taylor-Hood basis functions for
%                    selected faces. 
%
% SYNOPSIS:
%   V = evalBasisFunc(faces, G, CG, Dofs, w, fluid, rock, element, basis)
%   V = evalBasisFunc(faces, G, CG, Dofs, w, fluid, rock, element, basis,...
%                     'pn1', pv1, ...)
%
% PARAMETERS:
%   faces    - List (array) of coarse faces for which (new) basis function
%              values are requested.  Must be a list of explicit indices.
%              Function 'evalBasisFunc' does not support a LOGICAL array.
%
%   G, CG    - Underlying grid (G, see 'grid_structure') and coarse grid
%              model (CG) defined by function 'generateCoarseGridSB'.
%
%   Dofs     - Structure of Degrees-of-freedom generated by 'findCartDofs'.
%
%   w        - Array of numerically evaluated synthetic volume source
%              weighting term.  One scalar value for each cell in the
%              underlying fine grid G.  All values must be supplied, even
%              if some of the cells do not participate in the any of the
%              basis functions for 'faces'.
%
%   fluid    - Fluid object as defined by function initSingleFluid.
%
%   rock     - Rock data structure with valid field 'perm'. If the basis
%              functions are to be weighted by porosity, rock must also
%              contain a valid field 'poros'.
%
%   element  - A string explaining which elements are used (ex. 'TH').
%
%   basis    - A string explaining which basis are used (ex. 'TH').
%
%   'pn'/pv  - List of 'key'/value pairs defining optional parameters.  The
%              supported options are:
%                - src -- Explicit source terms in the underlying fine grid
%                         model which must be taken into account when
%                         generating the basis functions.  Note that basis
%                         functions in blocks containing an explicit source
%                         term will be generated based solely on the
%                         explicit source.  The values in 'weight'
%                         pertaining to such blocks will be ignored.
%
%                         Must be a source data structure as defined by
%                         function 'addSource'.  Default value is [] (an
%                         empty array), meaning that no explicit sources
%                         are present in the model.
%
%                - bc  -- External boundary conditions.
%                         Must be a boundary condition data structure as
%                         defined by function 'addBCSB'.  Default value is []
%                         (an empty array), meaning that no boundary
%                         conditions are present in the model.
%
%                - Overlap --
%                         The number of fine-scale cells by which to extend
%                         the support of a given flux or pressure basis
%                         function into neighbouring coarse blocks.  Note
%                         well: Using Overlap > 0 precludes hybrid
%                         formulation of the resulting coarse system of
%                         linear equations.  Default value: Overlap = 0
%                         (don't extend the basis function support).
%
%   LinSolve     - Handle to linear system solver software to which the
%                  fully assembled system of linear equations will be
%                  passed.  Assumed to support the syntax
%
%                        x = LinSolve(A, b)
%
%                  in order to solve a system Ax=b of linear equations.
%                  Default value: LinSolve = @mldivide (backslash).
%
% RETURNS:
%   V - Cell array, one element for each coarse face in 'faces', of cell
%       arrays (tuples) of SPARSE input vectors (and auxillary information)
%       from which the flux basis function matrix \Psi may be formed.
%

  if ~isnumeric(faces),
    error(msgid('Faces:NonNumeric'), ...
          'Argument ''faces'' must be a numeric array.');
  end
  
  opt = struct('Verbose', false, 'Overlap', 0, 'src', [], 'bc', [], ...
               'LinSolve', @mldivide);
  opt = merge_options(opt, varargin{:});
  
  linSolv = opt.LinSolve;
  part    = get_partition(CG);
  nhV_blk = accumarray(part, double(size(Dofs.HalfDofs,2)));
  nBlk    = max(part);
  dim     = numel(G.cartDims);
  
  [sub_map, dum] = mappings(G, CG, part, opt);

  % Driving forces (sources and BCs).
  [is_pressure, pval] = expand_bc(G, opt.bc);
  theta               = get_coarse_weighting(G, part, w, opt.src); 

  renum_v   = zeros([Dofs.numHalfDofs, 1]);
  ihV_other = false([Dofs.numHalfDofs, 1]);
  
  V = cell([numel(faces), 1]);
  
  sgn      = [1, -1];
  src_mult = zeros([nBlk, 1]);
   
  for f = 1 : numel(faces),
  
      face        = faces(f);
      [nsub, sub] = subFaces(G, CG);
      sub_ix      = cumsum([0; nsub]);
      subfaces    = sub(sub_ix(face) + 1 : sub_ix(face + 1));
      facearea    = sum(G.faces.areas(subfaces)); % Area of coarse face
    
      blk  = CG.faces.neighbors(face,:); % Blocks connected to 'face'
      blk  = blk(blk > 0);
      nblk = numel(blk);                 % Number of blocks sharing 'face'
      
      iC   = sub_map.cells(blk);  % Fine-scale cells present in 'blk'
      iV   = Dofs.Vdofs(iC,:);    % Fine-scale vdofs present in 'blk'
      ihV  = Dofs.HalfDofs(iC,:); % Fine-scale half-vdofs present in 'blk'
      iP   = Dofs.Pdofs(iC,:);    % Fine-scale vdofs present in 'blk'
      nihV = numel(unique(ihV));
      
      % Build components for system.
      % 1) Define driving source term:
      %      +1*facearea source strength in blk(1)
      %      -1*facearea source strength in blk(2) (if nblk > 1)
      %       0 source strength elsewhere (if opt.Overlap > 0)
      if (numel(blk)==1)
        % The coarse face 'face' is on the boundary of the domain.
        fface  = sub_map.sub_f(face);
        cellNo = rldecode(1:G.cells.num, double(G.cells.numFaces), 2).';
        cellf  = G.faces.neighbors(fface(1),:);
        if(find(iC==cellf(1))) 
          cellf=cellf(1);
        else 
          cellf=cellf(2);
        end
        
        hf   = find(cellNo==cellf&G.cellFaces(:,1)==fface(1));
        ftag = G.cellFaces(hf,2);
        if (ftag==1 || ftag==3 || ftag==5)
          src_mult(blk)=-1;
        else
          src_mult(blk)=1;
        end
      else
        % The coarse face 'face' is within the domain.
        src_mult(blk) = sgn(1 : nblk); 
      end
      
      sC = theta(iC) .* src_mult(part(iC)) * facearea;
      src_mult(blk) = 0;
      
      sN=zeros([Dofs.numPdofs, 1]);  % Nodal sink/source term
      for i=1:length(iC),
        sN(Dofs.Pdofs(iC(i),:)) = sN(Dofs.Pdofs(iC(i),:))+sC(i)/size(Dofs.Pdofs,2);
      end
                  
      % 2) Prepare making of system
      uiV = unique(iV);
      uiP = unique(iP);
      loc_iV  = findLocDofs(iV);
      loc_ihV = findLocDofs(ihV);
      loc_iP  = findLocDofs(iP);
      subG = [];
      subG.cells.num = length(iC);
      subG.cartDims  = G.cartDims;
      subDofs = []; 
      subDofs.numVdofs = length(uiV);
      subDofs.numPdofs = length(uiP); 
      subDofs.Vdofs    = loc_iV;
      subDofs.Pdofs    = loc_iP; 
      subrock = []; 
      subrock.perm = rock.perm(iC,:);
      dxvec = find_dx(G, iC);
              
      % 3) Make boundary condition structure
      [bcfaces, tags]  = find_bf(G, part, blk, iC);
      bcp              = find(is_pressure);
      [bcp, dum, dum]  = intersect(bcp, subfaces);
      [bcv, ind_v] = setdiff(bcfaces, bcp);
      [dum, ind_p] = setdiff(bcfaces, bcv);

      if(any(bcp))
        subBC = addBCSB([],bcp, 'pressure', pval(bcp), G, Dofs, ...
                        'facetag', tags(ind_p));
        subBC = addBCSB(subBC,bcv, 'velocity_n', repmat(0,length(bcv),1), ...
                        G, Dofs, 'facetag', tags(ind_v));
      else
         subBC = addBCSB([],bcfaces, 'velocity_n', repmat(0,length(bcfaces),1), ...
                          G, Dofs, 'facetag', tags); 
         subBC.p.unique = [1,0];
                     
      end
            
      glob2locVdofs = zeros(max(max(iV)),1);
      glob2locVdofs(reshape(iV,[],1)) = reshape(loc_iV, [],1);
      subBC.node    = glob2locVdofs(subBC.node); % in local numbering  
      
     
      
      % 4) Make system structure with automatic incorporation of no-flow bc
      %    for taylor hood. 
      if strcmp(element,'TH')  
        subS = makeSystemSB(subG, subDofs, subrock, fluid, 'dx', dxvec, ...
                             'element', element, 'bc', subBC);
      elseif strcmp(element,'ElementMat2D_modTH') 
        subS = makeSystem_sb_modTH(subG, subDofs, subrock, fluid, 'dx', dxvec, ...
                                   'element', element, 'basis', basis);
      elseif strcmp(element,'ElementMat2D_modTH2') 
        subS = makeSystem_sb_modTH2(subG, subDofs, subrock, fluid, 'dx', dxvec, ...
                                    'element', element, 'basis', basis);
      elseif strcmp(element,'ElementMat2D_modTH3') 
        subS = makeSystem_sb_modTH3(subG, subDofs, subrock, fluid, 'dx', dxvec, ...
                                    'element', element, 'basis', basis);
      else
        error('Unknown element');
      end
      subS.Q = sN(uiP);
              
      % 5) Apply pressure bc (and no-flow for other elements than 'TH'):
      if ~strcmp(element, 'TH')
         subS = setBCSB_vn(subS, subBC);
      end    
      if(any(bcp))
         subS = setBCSB_p( subS, subBC, subDofs, subG, 'dx', dxvec);       
      else
         subS = setBCSB_p_unique(subS,subBC);
      end
      
      
      % 6) Solve system
      [subS,sol] = solve_system(subS, subDofs, linSolv);
      
      
      uihV = reshape(unique(ihV),[],1);
      v1   = sparse(reshape(loc_ihV,[],1),...
                    1,...
                    sol.v1(reshape(loc_iV,[],1)), ...
                    numel(uihV),...
                    1);
      v2   = sparse(reshape(loc_ihV,[],1),...
                    1,...
                    sol.v2(reshape(loc_iV,[],1)), ...
                    numel(uihV),...
                    1);
      if dim==3
        v3 = sparse(reshape(loc_ihV,[],1),...
                    1,...
                    sol.v3(reshape(loc_iV,[],1)), ...
                    numel(uihV),...
                    1);
      end
      
      % 7) Make V{face}.
      % Reorder the unknowns/entries into v in order to have the
      % entries corresponding to blk(1) stored *first* in the following
      % SPARSE tuples.
      %
      % Algorithm:
      %   1) Create local numbering of entries (renum_v = ...)
      %   2) Mark entries outside blk(1) as being outside
      %      (ihV_other = true, ihV_other(blk(1)) = false)
      %   3) Put blk(1) entries first in index vector (ix_v = ...)
      %   4) Clean up blk(2:end) entries to prepare for next loop
      %      iteration, i.e., next basis function, (ihV_other = false).
      %
      
      iC1 = find(part == blk(1)); 

      renum_v(uihV) = 1:nihV;         ihV_other(uihV) = true;
      ihV1 = Dofs.HalfDofs(iC1,:);    ihV_other(ihV1) = false;
      ix_v = [renum_v(unique(ihV1)); ...
              renum_v(ihV_other)];    ihV_other(ihV)  = false;
                                      
      % SPARSE input duplets [i, v1, v2, v3] and auxillary information used to form
      % either the hybrid or mixed flux basis function matrix 'Psi'.  The tuples are
      %
      %    1   2   3   4  5  6      for 2-D and %    1  2  3  4  5  6  7
      %   {i, v1, v2,  f, b, n}                 %   {i, s, f, b, n, m, o}
      %    1   2   3   4  5  6  7   for 3-D
      %   {i, v1, v2, v3, f, b, n}
      %
      % with 'f' being the coarse face to which the values are associated,
      % 'b' being the coarse block(s) connected to 'f'.  Furthermore, 'n'
      % is the number of entries in [i,v1, v2, v3] belonging to the *first* coarse
      % block (b(1)).  The coarse hybrid solver cannot be employed if any
      % basis function is generated with a positive amount of overlap.
      %
      % The entry 'n' (i.e., V{k}{6} or  V{k}{7}) is only used when forming
      % the *hybrid* basis matrices. We note that the remaining SPARSE
      % input vector 'j' is formed differently depending on which type of
      % basis function matrix to construct (hybrid or mixed).  See the
      % sub functions split_for_hybrid and expand_mixed in
      % solveIncompFlowMS for details. 
      %
      if dim==2
         V{f} = {uihV(ix_v), ...
                 v1(ix_v), ...
                 v2(ix_v), ...
                 face, ...
                 blk, ...
                 nhV_blk(blk)};
      elseif dim==3     
         V{f} = {uihV(ix_v), ...
                 v1(ix_v), ...
                 v2(ix_v), ...
                 v3(ix_v), ...
                 face, ...
                 blk, ...
                 nhV_blk(blk)};
      end
  end
  
%--------------------------------------------------------------------------
% Helpers follow.
%--------------------------------------------------------------------------

function locDofs=findLocDofs(dofs)
% findLocDofs -- find local dofs for local systems
%
  ui      = unique(dofs);
  locDofs = dofs;
  for i = 1:size(dofs,1),
    for j = 1:size(dofs,2),
      locDofs(i,j) = find(ui==dofs(i,j));
    end
  end
  
%--------------------------------------------------------------------------

function p = get_partition(cg)
% get_partition -- Extract explicit partition vector from coarse grid.
%
% SYNOPSIS:
%   p = get_partition(CG)
%
% PARAMETERS:
%   CG - Coarse grid structure.
%
% RETURNS:
%   p  - Partition vector used in creating the coarse grid.

   p     = zeros([size(cg.cells.subCells,1), 1]);
   [i,j] = find(cg.cells.subCells);
   p(i)  = j;


%--------------------------------------------------------------------------

function [ops, nc] = mappings(G, CG, p, opt)
% mappings - Build essential grid mappings for coarse grid.
%
% SYNOPSIS:
%   [ops, nc] = mappings(G, CG, p, opt)
%
% PARAMETERS:
%   G, CG - Fine grid and coarse grid data structures, respectively.
%   p     - Partition vector, size [G.cells.num,1], such that p(i) is the
%           coarse block containing cell 'i'.  This is assumed to be the
%           original partition vector which created the coarse grid.
%   opt   - Option structure describing external influences (and, in
%           particular, external boundary conditions).  Also, assumed to
%           contain a scalar field 'Overlap' denoting the number of cells
%           by which to extend support of the basis functions into
%           neighbouring coarse blocks.  Note: Overlap > 0 precludes hybrid
%           formulation of the resulting coarse system.
%
% RETURNS:
%   ops - A data structure whose fields are functions defining particular
%         aspects of mapping topological information from the fine grid to
%         the coarse grid.  Specifically, the fields are
%            - cells - Function @(b) -> fine cells attached to blocks 'b'.
%            - hf    - Function @(c) -> fine half-faces in fine cells 'c'.
%            - faces - Function @(i) -> fine faces corresponding to hf 'i'.
%            - sub_f - Function @(f) -> constituent fine faces of coarse
%                      face 'f'.  Defined non-trivially only when there are
%                      any external (coarse) faces supporting flow (i.e.,
%                      not no-flow conditions) and for which (flux) basis
%                      functions must be computed.
%   nc  - Array of size [CG.cells.num, 1] containing the number of
%         fine-scale cells in each block.  Specifically, nc(b) is the
%         number of fine-scale cells in coarse block 'b'.

% Compute 'sub_f' mapping depending on existence of any outer coarse
% faces supporting flow (i.e., BC is not no-flow).  See 'help subFaces'
% for details on MCOLON expression.
  if ~isempty(opt.bc),
    [nsub, sub] = subFaces(G, CG);
    sub_ix      = cumsum([0; nsub]);
    sub_f       = @(f) sub(mcolon(sub_ix(f) + 1, sub_ix(f + 1)));
  else
    % Dangerous.  Assumes we won't be called upon to build a basis
    % function for an outer coarse face (f) if there are no external
    % boundary conditions...
    sub_f       = @(f) [];
  end
  
  % Count number of cells and number of half-faces in all coarse blocks.
  nc  = accumarray(p, 1);
  nhf = accumarray(p, double(G.cells.numFaces));
  
  % sub_c(:,b) == true for all cells (rows) within (extended) block 'b'.
  sub_c = sub_cells(G, p, opt.Overlap);
  
  % cellno(i) == (fine-scale) cell which contains half-face 'i'.
  % hfix      -- Index into 'G.cellFaces'.  Specifically, data concerning
  %              fine-scale cell 'c' occupies rows [hfix(c)+1 : hfix(c+1)]
  %              of 'G.cellFaces'.
  %
  cellno = rldecode(1 : G.cells.num, double(G.cells.numFaces), 2) .';
  hfix   = cumsum([0; double(G.cells.numFaces)]);
  
  %-----------------------------------------------------------------------
  % Define mapping operators. --------------------------------------------
  %
  %   1) ops.cells:
  %      any(sub_c(:,b), 2) is true for all fine-scale cells in the
  %      (possibly extended) block(s) 'b'.
  %
  ops.cells = @(b) find(any(sub_c(:,b), 2));
  
  %   2) ops.hf:
  %      Transpose because MCOLON gives row-vector, while we need columns.
  %
  ops.hf    = @(c) mcolon(hfix(c) + 1, hfix(c + 1)).';
  
  %   3) ops.faces:
  %      FIND those faces mentioned at least once in the half-faces 'i'.
  %
  ops.faces = @(i) find(accumarray(G.cellFaces(i,1), 1) > 0);
  
  %   4) ops.sub_f:
  %      See above.
  %
  ops.sub_f = sub_f;
  
  %   5) ops.dmob:
  %      mob(cellno(i)) is (total) mobility in cell containing half-face
  %      'i'.
  %
  ops.dmob  = @(i,n) spdiags(mob(cellno(i)), 0, n, n);
  
%--------------------------------------------------------------------------

function theta = get_coarse_weighting(G, p, w, src)
% All synthetic weighting terms must be strictly non-negative.
%
  assert (~any(w < 0));
  
  % Initially, assume there are no explicit/external sources.
  %
  theta = w .* G.cells.volumes;
  
  if ~isempty(src),
    % Update for explicit sources if there nevertheless are some...
    
    % Determine coarse blocks already containing external sources.
    %
    has_src = accumarray(p(src.cell), 1, [max(p), 1]) > 0;
    
    % Eliminate previous (synthetic) weighting and apply correct source.
    %
    theta(has_src(p)) = 0;
    theta(src.cell)   = src.rate;
  end
  
  % Note:
  %   We need to normalize the (synthetic or explicit) source term 'theta'
  %   such that \int_{B_i} theta d\Omega == 1 lest the basis functions be
  %   inconsistent.
  %
  
  denom = accumarray(p, theta);  assert (all(abs(denom) > 0));
  theta = theta ./ denom(p);
  
%--------------------------------------------------------------------------

function [d, val] = expand_bc(G, BC)
  d   = false([G.faces.num, 1]);
  val = zeros([G.faces.num, 1]);
  if ~isempty(BC),
    assert (all(accumarray(BC.face, 1, [G.faces.num, 1]) <= 1));
    
    is_dir = BC.type == 2;
    d(BC.face(is_dir))   = true;
    val(BC.face(is_dir)) = BC.value(is_dir);
  end
  
%--------------------------------------------------------------------------

function sub_c = sub_cells(g, p, overlap)
  nc    = g.cells.num;
  sub_c = sparse(1 : nc, p, 1, nc, max(p));  % == cg.cells.subCells
  
  if overlap > 0,
    n = double(g.faces.neighbors(all(g.faces.neighbors > 0, 2), :));
    n = sparse([n(:,1); n(:,2); (1 : nc).'], ...
               [n(:,2); n(:,1); (1 : nc).'], 1, nc, nc);
    
    % BFS to discover immediate neighbours in overlap region.
    for o = 1 : overlap, sub_c = n * sub_c; end
  end
  
  sub_c = logical(sub_c);
  
%--------------------------------------------------------------------------

function dxvec = find_dx(G, iC)
  
  dim = numel(G.cartDims);
  dxi = find(G.cellFaces(:,2)==1);  dxj = find(G.cellFaces(:,2)==2);
  dyi = find(G.cellFaces(:,2)==3);  dyj = find(G.cellFaces(:,2)==4);
  dx  = G.faces.centroids(G.cellFaces(dxj,1),1)-...
        G.faces.centroids(G.cellFaces(dxi,1),1); 
  dy  = G.faces.centroids(G.cellFaces(dyj,1),2)-...
        G.faces.centroids(G.cellFaces(dyi,1),2); 
  dx  = dx(iC); dy = dy(iC); 
  dxvec = struct('dx',dx,'dy',dy);
  if dim==3
    dzi = find(G.cellFaces(:,2)==5);  dzj = find(G.cellFaces(:,2)==6);
     dz  = G.faces.centroids(G.cellFaces(dzj,1),3)-...
           G.faces.centroids(G.cellFaces(dzi,1),3); 
     dz  = dz(iC);
     dxvec.dz = dz;
  end
  
%--------------------------------------------------------------------------

function [bcfaces, tags]=find_bf(G, part, blocks, iC)
% findBF -- Finds boundary faces for the local system consisting of
%           blocks in vector 'blocks'
%
% SYNOPSIS:
%   bcfaces = find_bf(G, part, blocks)
%
% PARAMETERS:
%   G       - Grid structure.
%
%   part    - A vector mapping cells to coarse blocks.
%
%   blocks  - A vector consisting of two coarse blocks defining the system
%
% RETURNS:
%   bcfaces - Faces on the boundary of the system
%  
  
  error(nargchk(4, 4, nargin, 'struct'));

  p  = [0;part];
  pN = p(G.faces.neighbors+1);
  i  = pN(:,1)~=pN(:,2);
  if(numel(blocks)==2)
    bdry = i&xor(any(pN==blocks(1),2),any(pN==blocks(2),2));
  elseif (numel(blocks)==1)
    bdry = i&any(pN==blocks(1),2);
  end
  bcfaces = find(bdry);
  
  fix = cumsum([0; double(G.cells.numFaces)]);
  ix  = @(c) mcolon(fix(c)+1, fix(c+1));
  cf  = G.cellFaces(ix(iC),:);
  
  dum          = false(G.faces.num,1);
  dum(bcfaces) = true;
  tags         = cf(dum(cf(:,1)),2);
  bcfaces      = cf(dum(cf(:,1)),1);

%--------------------------------------------------------------------------

function [subS,sol]=solve_system(subS, subDofs, linSolv)
  
  if isfield(subS,'B3')
      dim = 3;
  else
      dim = 2;
  end

  sb1 = size(subS.B1); sb11=sb1(1); sb12=sb1(2);
  sb2 = size(subS.B2); sb21=sb2(1); sb22=sb2(2);
  if dim==3
      sb3 = size(subS.B3); sb31=sb3(1); sb32=sb3(2);
  end

  beta = 1./(max(max(abs([subS.B1,subS.B2])))/...
           max(max(abs([subS.C1,subS.C2]))));

 if strcmp(subS.element,'ElementMat2D_modTH2')
  if dim==2
    B = [subS.B1*beta      sparse(sb21,sb22) subS.C1     ;...
         sparse(sb11,sb12) subS.B2*beta      subS.C2     ;...
         subS.D1           subS.D2           subS.P0/beta];
    F = [subS.F1    ;...
         subS.F2    ;...
         subS.Q/beta];
  elseif dim==3
    B = [subS.B1*beta      sparse(sb21,sb22) sparse(sb31,sb32) subS.C1   ;...
         sparse(sb11,sb12) subS.B2*beta      sparse(sb31,sb32) subS.C2   ;...
         sparse(sb11,sb12) sparse(sb21,sb22) subS.B3*beta      subS.C3   ;...
         subS.D1           subS.D2           subS.D3           subS.P0/beta];
    F = [subS.F1    ;...
         subS.F2    ;...
         subS.F3    ;...
         subS.Q/beta];
  end
 else
   if dim==2
    B = [subS.B1*beta      sparse(sb21,sb22) subS.C1     ;...
         sparse(sb11,sb12) subS.B2*beta      subS.C2     ;...
         subS.C1'          subS.C2'          subS.P0/beta];
    F = [subS.F1    ;...
         subS.F2    ;...
         subS.Q/beta];
  elseif dim==3
    B = [subS.B1*beta      sparse(sb21,sb22) sparse(sb31,sb32) subS.C1      ;...
         sparse(sb11,sb12) subS.B2*beta      sparse(sb31,sb32) subS.C2      ;...
         sparse(sb11,sb12) sparse(sb21,sb22) subS.B3*beta      subS.C3      ;...
         subS.C1'          subS.C2'          subS.C3'          subS.P0/beta];
    F = [subS.F1     ;...
         subS.F2     ;...
         subS.F3     ;...
         subS.Q/beta];
    end
 end
    
  solution=linSolv(B,F);
  sol.v1 = solution(                 1:  subDofs.numVdofs)*beta; 
  sol.v2 = solution(subDofs.numVdofs+1:2*subDofs.numVdofs)*beta;
  if dim==2
    sol.p  = -solution(2*subDofs.numVdofs+1:end);
  elseif dim==3
    sol.v3 =  solution(2*subDofs.numVdofs+1:3*subDofs.numVdofs)*beta;
    sol.p  = -solution(3*subDofs.numVdofs+1:end);
  end
 
